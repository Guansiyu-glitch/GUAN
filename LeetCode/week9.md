#### week9

力扣：141 21 203 206 83 20 232 144 242 383 387 73 36

笔记总结：

1.判定字符是否唯一

总结： 把字符串中每个字符转化为一个二进制数，转化方法为1向左N位的位运算，N为这个字符和字符‘a'的距离；

例如 Na = 0,Nb=1,Nc = 2...a = 1<<0 = 1 ,b = 1<<1 = 10, c = 1<<2 = 100..；

所以，每个字符串对应位置为1；

这种情况下，如果当前字符如果曾经出现过，也就是其中某一位对应位数的值为1，就意味着曾经出现，返回False；

否则，如果没有出现过，那么通过|或运算，把这一位的值改写为1；

例如 'abca' ： a= 1,b=10,c=100,前三次结果mark为111，最后一次111与001有相同符合条件，返回False

2,a&&b与a&b的区别 :就前者而言，当判断a的结果为false的时候可以直接返回整个表达式的结果为false,而不用继续判断b的结果是true还是false，但对于后者而言，即使判断a的结果为false，但是它仍然会判断b的值是什么，这样效率没有前者高，所以一般使用前者。

3.charAt(i) 函数

charAt(i) 函数 是获取字符串中i位置的字符

str.charAt(i)的意思是第i个字符在字符串str中所占的位置，输出的是数字.

4 二叉树中序遍历问题

非递归思路与算法：（没太看懂）

Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)O(1)。

Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 xx）：

如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x = x.\textit{right}x=x.right。
如果 xx 有左孩子，则找到 xx 左子树上最右的节点（即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点），我们记为 \textit{predecessor}predecessor。根据 \textit{predecessor}predecessor 的右孩子是否为空，进行如下操作。
如果 \textit{predecessor}predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即 x = x.\textit{left}x=x.left。
如果 \textit{predecessor}predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 \textit{predecessor}predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即 x = x.\textit{right}x=x.right。
重复上述操作，直至访问完整棵树。



5.环形链表问题

快慢指针法（龟兔赛跑算法）具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

 心得：

经过这一个月的学习，刷了一些简单中等难度的题，对基本的算法，递归思想，迭代思想，双指针，快慢指针，哈希表，栈有了更深的理解和应用。面对一个陌生的题时，不会像之前一样毫无头绪，至少会有一点点思路，但自己完成编程还是有些困难，总是报错，语法错误逻辑错误很多。还需加强训练，希望接下来一起做项目的过程对我来说有所提升与帮助。

